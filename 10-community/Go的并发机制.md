## 原理

在操作系统提供的内核线程上，Go搭建了一个特有的两级线程模型——goroutine（Go语言的开发者专门创建了这样一个名词以示区分，他们认为已经存在的线程，协程，进程等术语都传达了错误的含义）



**goroutine —— 不要用共享内存的方式来通信，作为代替，应该使用通信手段来共享内存**

Go不推荐使用共享内存的方式传递数据，而推荐使用channel。channel主要用来在多个goroutine之间传递数据，而且还会保证整个过程并发安全性。不过`作为可选方法`Go依然提供了一些传统的同步方法，如互斥量，条件变量等。

Go的并发机制指的是用于支撑goroutine和channel的底层原理 

## channel

channel既指通道类型，也指代可以传递某种类型的值得通道，通道即某一个通道类型的值，是该类型的一个实例

声明一个chan int类型的变量

`var intChan chan int`  //在初始化狗变量intChan就可以用来传递int类型的元素值了

这种声明方式意味着该通道类型是双向的，可以通过此类通道发送和接收元素值

声明单向通道

只用于发送值的通道类型 `chan <- T ` 只能向此类通道发送元素值，而不能从它那里接收元素值
只用于接收值的通道类型 ` <- chan  T`  

通道类型是一个引用类型，所以一个通道类型的变量在被初始化之前，其值一定是nil，也是此类型的零值

通道类型的变量是用来传递值的，而不是存储值的，所以通道类型没有对应额值表示法，他的值具有即时性，是无法用字面量来准确表达的

操作的特性

通道是在多个goroutine之间传递数据和同步的重要手段，而对通道操作的本身也是**同步**的 。在同一时刻，仅有一个goroutine能向一个通道发送元素值，同时也仅有一个goroutine能从它那里接收元素值。在通道中，各个元素值都是严格按照发送到此的先后顺序排列的，最早被发现送至通道的元素值会被先接收到。因此通道相当于一个FIFO(先进先出)的消息队列。此外通道通的元素值都具有原子性是不可被分割的，通道中的每一个元素值都可能被某一个goroutine接收，已被接收的元素值会立刻从通道中删除









